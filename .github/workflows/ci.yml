name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.11']

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: pip

      # Keep this cross-platform: use bash shell explicitly for all script steps
      - name: Install dev deps
        shell: bash
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements-dev.txt ]; then python -m pip install -r requirements-dev.txt; fi
          if [ -f requirements.txt ]; then python -m pip install -r requirements.txt; fi
          if [ -f setup.py ] || [ -f pyproject.toml ]; then python -m pip install -e .; fi

      - name: Bootstrap (make bootstrap if present)
        shell: bash
        run: |
          if [ -f Makefile ]; then
            make -n bootstrap >/dev/null 2>&1 && make bootstrap || true
          fi

      - name: MAL schema sanity (optional)
        if: ${{ hashFiles('scripts/mal_ci_checks.py') != '' }}
        shell: bash
        run: |
          python scripts/mal_ci_checks.py \
            --schema 8-RESOURCES/TEMPLATES/MAL/manifest.schema.json \
            --verbose

      - name: Lint canonical extensions (make lint if present)
        shell: bash
        run: |
          if [ -f Makefile ]; then
            make -n lint >/dev/null 2>&1 && make lint || true
          fi
          # fallback to direct linter if Make target not defined
          if [ -f tools/lint_extensions.py ]; then
            python tools/lint_extensions.py
          fi

      - name: Core tests (prefer .ci/Makefile)
        shell: bash
        run: |
          if [ -f .ci/Makefile ]; then
            make -f .ci/Makefile test
          elif [ -f Makefile ]; then
            make -n test >/dev/null 2>&1 && make test || true
          else
            echo "No test harness found; skipping."
          fi

      - name: Plan canonical migration (dry-run)
        shell: bash
        run: |
          if [ -f tools/migrate_extensions.py ]; then
            python tools/migrate_extensions.py || true
          fi

      - name: Verify no pending renames on protected branches
        if: ${{ github.ref == 'refs/heads/main' }}
        shell: bash
        run: |
          if [ -f Makefile ]; then
            make -n canonical-verify >/dev/null 2>&1 && make canonical-verify || true
          fi

      - name: Validate NATO-PNR records (hardened)
        shell: bash
        run: |
          python - << 'PY'
          import re, sys, yaml, glob

          errs=[]
          nsn_re  = re.compile(r"^[0-9]{4}-[0-9]{2}-[0-9]{7}$")
          niin_re = re.compile(r"^[0-9]{9}$")
          cage_re = re.compile(r"^[A-Z0-9]{5}$")
          icn_re  = re.compile(r"^[0-9]{2}-[A-Z]{2,3}-[A-Z]{2,3}-[A-Z]{2,4}-[0-9]{3}$")
          dm_re   = re.compile(r"^DMC-[A-Z0-9-]+\.XML$")
          TFA_LLC = {"SI","DI","SE","CV","CE","CC","CI","CP","CB","QB","UE","FE","FWD","QS"}
          SPARE   = {"ROTABLE","REPAIRABLE","CONSUMABLE","KIT"}

          pnr_ids=set(); nsns=set(); mpns=set()

          def nsn_digits(nsn:str)->str: return nsn.replace("-","")

          for p in glob.glob("8-RESOURCES/CATALOGS/pnr/*.yaml"):
            try:
              d = yaml.safe_load(open(p, encoding='utf-8'))
            except Exception as e:
              errs.append(f"{p}: YAML load error: {e}")
              continue

            # Required
            for k in ["pnr_id","item_name","ata_chapter","sns","tfa_llc","spare_class","cax_targets"]:
              if k not in d: errs.append(f"{p}: missing {k}")

            # Enums
            if "tfa_llc" in d and d["tfa_llc"] not in TFA_LLC:
              errs.append(f"{p}: tfa_llc '{d['tfa_llc']}' not in {sorted(TFA_LLC)}")
            if "spare_class" in d and d["spare_class"] not in SPARE:
              errs.append(f"{p}: spare_class '{d['spare_class']}' not in {sorted(SPARE)}")

            # Uniqueness
            pid = d.get("pnr_id")
            if pid:
              if pid in pnr_ids: errs.append(f"{p}: duplicated pnr_id {pid}")
              pnr_ids.add(pid)

            nsn = d.get("nsn")
            if nsn:
              if not nsn_re.match(nsn): errs.append(f"{p}: bad NSN {nsn}")
              if nsn in nsns: errs.append(f"{p}: duplicated NSN {nsn}")
              nsns.add(nsn)

            mpn = d.get("mpn")
            if mpn:
              if mpn in mpns: errs.append(f"{p}: duplicated MPN {mpn}")
              mpns.add(mpn)

            # NIIN & NSN/NCB consistency
            niin = d.get("niin")
            if niin and not niin_re.match(str(niin).zfill(9)):
              errs.append(f"{p}: bad NIIN {niin}")
            if nsn and niin:
              nd = nsn_digits(nsn)
              nsn_niin = nd[-9:]
              if nsn_niin != str(niin).zfill(9):
                errs.append(f"{p}: NSN/NIIN mismatch (NSN last9={nsn_niin} vs NIIN={niin})")
              ncb = nd[4:6]
              if ncb != str(niin).zfill(9)[:2]:
                errs.append(f"{p}: NCB mismatch (NSN NCB={ncb} vs NIIN NCB={str(niin).zfill(9)[:2]})")

            # SNS = ATA * 100 (handles "NN" or "NN-NN")
            ata_raw = d.get("ata_chapter", "")
            m = re.match(r"^(\d{2})", str(ata_raw))
            ata = m.group(1) if m else ""
            try:
              if int(ata)*100 != int(d.get("sns", -1)):
                errs.append(f"{p}: SNS!=ATA*100 (ATA={ata}, SNS={d.get('sns')})")
            except Exception as e:
              errs.append(f"{p}: invalid ATA/SNS: {e}")

            # ICN structured
            icns = d.get("digital",{}).get("icn_structured")
            if icns and not icn_re.match(icns):
              errs.append(f"{p}: bad structured ICN {icns}")

            # dm_refs pattern
            for dm in (d.get("digital",{}).get("dm_refs") or []):
              if not dm_re.match(dm):
                errs.append(f"{p}: invalid dm_refs entry '{dm}'")

            # CAx minimal keys & non-empty strings
            ct = d.get("cax_targets",{}) or {}
            req = {
              "CAD":["tool","project","vault"],
              "CAE":["solver","deck_path","cluster"],
              "CAM":["cam_system","postproc","nc_store"],
              "CAT":["lab","rig","procedure_dm"],
              "CAS":["ietp","amm_dm","ri_dm"],
            }
            for key, subs in req.items():
              if key not in ct:
                errs.append(f"{p}: missing cax_targets.{key}")
                continue
              for sub in subs:
                val = ct[key].get(sub)
                if not isinstance(val, str) or not val.strip():
                  errs.append(f"{p}: cax_targets.{key}.{sub} must be non-empty string")

          if errs:
            print("\n".join(errs)); sys.exit(1)
          print("NATO-PNR records OK")
          PY
